<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ assembly name="$(SolutionDir)Libs\FxCopSdk.dll" #>
<#@ assembly name="$(SolutionDir)..\BinOutput\SD.CodeProblem.DevAssignment.Data.dll" #>
<#@ assembly name="$(SolutionDir)Libs\Microsoft.Cci.dll" #>
<#@ import namespace="Microsoft.Cci" #>
<#+
  Dictionary<System.String, System.String> globalClasses = new Dictionary<System.String, System.String>();
  List<string> ignoredTypes = new List<string>()
	{
		"ObjectChangeTracker",
		"CollectionHistoryEntryType",
		"CollectionHistory",
		"CollectionHistoryXRef",
		"ObjectsAddedToCollectionProperties",
		"ObjectsRemovedFromCollectionProperties",
		"ObjectState",
		"OriginalValuesDictionary",
		"ExtendedPropertiesDictionary",
		"CollectionHistoryXRef",
		"System.Collections.Generic.List<Client>",
		"System.Collections.Generic.List<Matter>",
		"System.Byte[]"
	};

  void SaveOutput(string outputFileName)
  {
      string templateDirectory = Path.GetDirectoryName(Host.TemplateFile) + @"\Generated";
      string outputFilePath = Path.Combine(templateDirectory, outputFileName);
      File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString());
      this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
  }
  string GenerateProperty(Property property)
  {

		Type propertyType = property.Type.GetRuntimeType();
		string targetType = propertyType.ToString();
		if(targetType.Contains("System.Nullable`1"))
		{
			targetType = targetType.Replace("`1[", "<").Replace("]", ">");
		}
		else if(targetType.Contains("SD.CodeProblem.DevAssignment.Data.DataModel."))
		{
			targetType =  targetType.Replace("SD.CodeProblem.DevAssignment.Data.DataModel.", "");
			
		}
		else if(targetType.Contains("System.Collections.Generic.List`1["))
		{
			targetType = targetType.Replace("`1[", "<").Replace("]", ">");
		}

		if(targetType.Contains("System.Collections.Generic.ICollection`1["))
		{
			targetType = targetType.Replace("`1[", "<").Replace("]", ">");
		}
		
		return targetType;
  }

  void GenerateDomainModelObject(string library, string sourceType, string targetClass)
  {
	if(globalClasses.ContainsKey(sourceType)) return;
	globalClasses.Add(sourceType, targetClass);
	
	System.IServiceProvider hostServiceProvider = (IServiceProvider)this.Host;
	EnvDTE.DTE dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
	string path = System.IO.Path.GetDirectoryName(dte.Solution.FullName) + @".\..\BinOutput\" + library;
#>
// ---------------------------------------------------------------------------------------------------
//<auto-generated>
//	This code was generated by a tool:  SD.CodeProblem.DevAssignment.Domain.Model -> Template.tt.
//  Generated date: '<#= DateTime.Now #>'
//	Any code changes can cause serious problems with model behaviour, and will be lost in next code generation. 
//	Please use 'partial' classes instead. 
//</auto-generated>
// ---------------------------------------------------------------------------------------------------
namespace SD.CodeProblem.DevAssignment.Domain.Model
{
<#+
	AssemblyNode assembly = AssemblyNode.GetAssembly(path);
	Identifier namespaceId = Identifier.For("SD.CodeProblem.DevAssignment.Data.DataModel");
	Identifier typeId = Identifier.For(sourceType);
    TypeNode typeInfo = assembly.GetType(namespaceId, typeId);
#>
	[System.CodeDom.Compiler.GeneratedCodeAttribute("DomainModelGenerator", "0.0.1")]
	public partial class  <#= targetClass #>
	{
<#+   
   foreach (Member member in typeInfo.Members)
   {
		if(member.IsPublic && member is Property)
		{
		Property property = member as Property;
		bool isReadonly  = !property.GetPropertyInfo().CanWrite || property.GetPropertyInfo().GetSetMethod() == null;
		string readonlyAttribute = isReadonly ? "[Readonly]" : "";
		string propertyTypeFullText = property.Type.GetRuntimeType().ToString();
		string propertyType = GenerateProperty(property);
		
   #>
		<#= ignoredTypes.Contains(propertyType) ? "//":""#><#=readonlyAttribute#>
		<#= ignoredTypes.Contains(propertyType) ? "//":""#><#= String.Format("public {0} {1} {{ get; set; }}", propertyType, property.Name) #>
<#+}}#>
	}
}
<#+ 
	SaveOutput(targetClass + ".generated.cs");
}
#>